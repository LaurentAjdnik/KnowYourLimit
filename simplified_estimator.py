"""
The module containing functions that simplify the estimation process.
"""


#
def estimator_energy_QAOA(noise_model,A,device,gammas,betas,verbose=1,method='TN'):
    """
    Returns a lower bound on the energy outputted by a QAOA circuit under noise.

    Args:
    
        noise_model(cirq quantum channel): cirq quantum channel specifying the noise affecting the device.
        A(scipy sparse matrix): the (weighted) adjacency matrix of the Ising model whose energy we wish to minimize.
        device(pytket device): the connectivity of the underllying device.
        gammas(list of floats): the Gamma parameters of the QAOA circuit, which correspond to the parameters of the unitary generated by the Ising model. 
        betas(list of floats): the Beta parameters of the QAOA circuit, which correspond to the paremeters of the X unitaries.
        verbose(bool): if set to 1, it will also print the depth of the compiled circuit and at which stage of the process we are at. If 0 there will be no output.
        method(str): either 'TN' or 'MC'. Determines which method will be used to compute the partition function. TN is tensor network, MC is Monte Carlo.
        
    """
    problem_graph=nx.from_scipy_sparse_matrix(A)
    noise=quantum_channel(noise_model)
    sigma=noise.fixed_point
    if verbose==1:
        print("Compiling circuit")
    circuit=compiled_routed_weighted_qaoa(problem_graph,gammas,betas,device)
    
    if verbose==1:
        
        print("Circuit compiled")
        print("The circuit has depth",len(circuit.moments))
    n_qubits=problem_graph.order()

    
    #determine external field
    sigma=noise.fixed_point
    y=sigma[0,0]-sigma[1,1]
    #weird normalization. I have encountered some versions of numpy that use base 2.
    beta_sigma=(0.5/np.log(np.exp(1)))*np.log((1+y)/(1-y))
    gamma=np.real(0.25*beta_sigma)
    if verbose==1:
        print("Estimating relative entropy of output")
    rel_ent=entropy_output(circuit,n_qubits,sigma,noise.contraction)
    if verbose==1:
        print("Estimating partition functions")
    [betas,log_partitions]=partition_function_estimator_Ising(beta0=0.01,beta1=5,A=A,gamma=gamma,method='TN',step_size=0.05)
    output_energy=best_estimate_rel_ent(betas,log_partitions,rel_ent,n=n_qubits,gamma=gamma)
    #ground_state_energy=ground_state_brute_force(A)
    #print(output_energy,ground_state_energy,noise.contraction)
    
    
    
    return np.real(output_energy) #output_energy,ground_state_energy